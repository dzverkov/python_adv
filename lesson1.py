
# 1.Каждое из слов «разработка», «сокет», «декоратор» представить в строковом формате и проверить тип и содержание
# соответствующих переменных. Затем с помощью онлайн-конвертера преобразовать строковые представление в формат Unicode
# и также проверить тип и содержимое переменных.
str1 = "разработка"
str2 = "сокет"
str3 = "декоратор"

print(f"str1 = {str1}, type = {type(str1)}")
print(f"str1 = {str2}, type = {type(str2)}")
print(f"str1 = {str3}, type = {type(str3)}")

# 2.Каждое из слов «class», «function», «method» записать в байтовом типе без преобразования в
# последовательность кодов (не используя методы encode и decode) и определить тип, содержимое и длину соответствующих
# переменных.


# 3.Определить, какие из слов «attribute», «класс», «функция», «type» невозможно записать в байтовом типе.

# 4.Преобразовать слова «разработка», «администрирование», «protocol», «standard» из строкового представления
# в байтовое и выполнить обратное преобразование (используя методы encode и decode).


# 5.Выполнить пинг веб-ресурсов yandex.ru, youtube.com и преобразовать результаты из байтовового в строковый тип
# на кириллице.


# 6.Создать текстовый файл test_file.txt, заполнить его тремя строками:
# «сетевое программирование», «сокет», «декоратор». Проверить кодировку файла по умолчанию.
# Принудительно открыть файл в формате Unicode и вывести его содержимое.


#Необходимые и достаточные условия

#    Реализовать приведение строк "разработка", "сокет", "декоратор" к типу bytes используя нативные методы строк;
#    Реализовать приведение полученных экземпляров типа bytes к типу str;
#    Реализовать приведение полученных строк и байтовых последовательностей с использование различных кодировок utf-8 latin-1